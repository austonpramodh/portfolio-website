import { SliceZone } from "@prismicio/react";
import * as prismicH from "@prismicio/helpers";

import { createClient, linkResolver } from "../prismicio";
import { components } from "../slices";
import { NextPage, GetStaticPaths, GetStaticProps } from "next";

// import NavBar from "../components/NavBar";
// import Footer from "../components/Footer";
import { ParsedUrlQuery } from "querystring";
import { Content } from "@prismicio/client";
import Layout from "../components/PageLayout";
import StaticDataContext, { StaticDataContextType } from "../components/StaticDataContext";
import NavBar from "../components/NavBar";
import ScrollSpy from "react-ui-scrollspy";
import SEO from "../components/Seo";
import { useEffect } from "react";

type PageProps = {
    page?: Content.AllDocumentTypes;
    //   defaultSEOData: SeoMetadataDocument;
    staticDataContext?: StaticDataContextType;
    error?: string;
};

const Page: NextPage<PageProps> = ({ page, staticDataContext, error }) => {
    useEffect(() => {
        console.log("Page Mounted");
        console.log("-----------------");
        console.log(staticDataContext?.last_publication_date);
        console.log("-----------------");
    }, []);

    if (error || !page || !staticDataContext) {
        return (
            <Layout>
                <div>{error}</div>
            </Layout>
        );
    }

    const pageTitle = (page.type === "page" && page.data.page_title) || "";

    return (
        <StaticDataContext.Provider value={staticDataContext}>
            <Layout>
                {/* <Head>
        <title>Create Next App</title>
        <meta name="description" content="Generated by create next app" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/favicon.ico" />
      </Head> */}
                <SEO title={pageTitle} />
                <NavBar
                    sections={[
                        {
                            link: "/#home",
                            label: "Home",
                            id: "home",
                        },
                        {
                            link: "/#about-me",
                            label: "About Me",
                            id: "about-me",
                        },
                        {
                            link: "/#services",
                            label: "Services",
                            id: "services",
                        },
                        {
                            link: "/#skills",
                            label: "Skills",
                            id: "skills",
                        },
                        {
                            link: "/#experiences",
                            label: "Experiences",
                            id: "experiences",
                        },
                        {
                            link: "/#contact-me",
                            label: "Contact Me",
                            id: "contact-me",
                        },
                    ]}
                />
                <ScrollSpy offsetBottom={200} offsetTop={100} useBoxMethod updateHistoryStack={false}>
                    {page.type === "page" && (
                        <SliceZone
                            slices={page.data.slices}
                            components={components}
                            context={{
                                test: true,
                            }}
                        />
                    )}
                </ScrollSpy>

                {/* <Footer /> */}
            </Layout>
        </StaticDataContext.Provider>
    );
};

export default Page;

function promiseWithTimeout<T>(
    promise: Promise<T>,
    ms: number,
    timeoutError = new Error("Promise timed out")
): Promise<T> {
    // create a promise that rejects in milliseconds
    const timeout = new Promise<never>((_, reject) => {
        setTimeout(() => {
            reject(timeoutError);
        }, ms);
    });

    // returns a race between timeout and the passed promise
    return Promise.race<T>([promise, timeout]);
}

export const getStaticProps: GetStaticProps<PageProps> = async ({ params, previewData }) => {
    console.log("Getting all Static Props");

    console.time("getStaticProps");

    if (previewData) {
        console.log("-----------------");
        console.log("getStaticProps:Preview Data", previewData);
        console.log("-----------------");
    }

    const client = createClient({ previewData });

    const uid = params?.pagePath?.[params.pagePath.length - 1] || "home";

    const allRequests = [
        client.getByUID("page", uid),
        client.getSingle("external_links"),
        client.getSingle("seo_data"),
        client.getSingle("resume"),
    ];

    try {
        // const [page, externalLinksDoc, seoDataDoc] = (await Promise.all(allRequests)) as [
        //     Content.AllDocumentTypes,
        //     Content.ExternalLinksDocument,
        //     Content.SeoDataDocument
        // ];
        const MAX_TIMEOUT = 5000;
        const [page, externalLinksDoc, seoDataDoc, resumeDataDoc] = (await promiseWithTimeout(
            Promise.all(allRequests),
            MAX_TIMEOUT,
            new Error("Get Static props timed out!")
        )) as [
            Content.AllDocumentTypes,
            Content.ExternalLinksDocument,
            Content.SeoDataDocument,
            Content.ResumeDocument
        ];

        console.log("Got all Static Props");
        console.timeEnd("getStaticProps");

        // Get the last publication date from all the documents
        let last_publication_date = page.last_publication_date;

        for (const doc of [externalLinksDoc, seoDataDoc, resumeDataDoc]) {
            if (doc?.last_publication_date && doc.last_publication_date > last_publication_date) {
                last_publication_date = doc.last_publication_date;
            }
        }

        return {
            props: {
                page,
                staticDataContext: {
                    externalLinksData: externalLinksDoc?.data || null,
                    seoData: seoDataDoc?.data || null,
                    resumeData: resumeDataDoc?.data || null,
                    last_publication_date,
                },
            },
        };
    } catch (error) {
        console.log("Error in getStaticProps", error);
        let message: string;
        if (error instanceof Error) message = error.message;
        else message = String(error);

        return {
            props: {
                error: message,
            },
        };
    }
};

interface Params extends ParsedUrlQuery {
    locale?: string | undefined;
}

// TODO: add typings for this
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
export const getStaticPaths: GetStaticPaths<Params> = async (params) => {
    console.log("Getting all Static Paths");

    console.log("-----------------");
    console.log("getStaticPaths:params", params);
    console.log("-----------------");

    const client = createClient();

    const pages = await client.getAllByType("page");

    return {
        paths: pages.map((page) => prismicH.asLink(page, linkResolver)),
        fallback: false,
    };
};
